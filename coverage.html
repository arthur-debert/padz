
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>padz-completions: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/arthur-debert/padz/cmd/padz-completions/main.go (0.0%)</option>
				
				<option value="file1">github.com/arthur-debert/padz/cmd/padz-manpage/main.go (0.0%)</option>
				
				<option value="file2">github.com/arthur-debert/padz/cmd/padz/cli/cleanup.go (0.0%)</option>
				
				<option value="file3">github.com/arthur-debert/padz/cmd/padz/cli/delete.go (0.0%)</option>
				
				<option value="file4">github.com/arthur-debert/padz/cmd/padz/cli/ls.go (0.0%)</option>
				
				<option value="file5">github.com/arthur-debert/padz/cmd/padz/cli/open.go (0.0%)</option>
				
				<option value="file6">github.com/arthur-debert/padz/cmd/padz/cli/peek.go (0.0%)</option>
				
				<option value="file7">github.com/arthur-debert/padz/cmd/padz/cli/root.go (0.0%)</option>
				
				<option value="file8">github.com/arthur-debert/padz/cmd/padz/cli/search.go (0.0%)</option>
				
				<option value="file9">github.com/arthur-debert/padz/cmd/padz/cli/view.go (0.0%)</option>
				
				<option value="file10">github.com/arthur-debert/padz/cmd/padz/main.go (0.0%)</option>
				
				<option value="file11">github.com/arthur-debert/padz/internal/version/version.go (0.0%)</option>
				
				<option value="file12">github.com/arthur-debert/padz/pkg/commands/cleanup.go (0.0%)</option>
				
				<option value="file13">github.com/arthur-debert/padz/pkg/commands/create.go (0.0%)</option>
				
				<option value="file14">github.com/arthur-debert/padz/pkg/commands/delete.go (0.0%)</option>
				
				<option value="file15">github.com/arthur-debert/padz/pkg/commands/ls.go (0.0%)</option>
				
				<option value="file16">github.com/arthur-debert/padz/pkg/commands/open.go (0.0%)</option>
				
				<option value="file17">github.com/arthur-debert/padz/pkg/commands/peek.go (0.0%)</option>
				
				<option value="file18">github.com/arthur-debert/padz/pkg/commands/search.go (0.0%)</option>
				
				<option value="file19">github.com/arthur-debert/padz/pkg/commands/view.go (0.0%)</option>
				
				<option value="file20">github.com/arthur-debert/padz/pkg/editor/editor.go (0.0%)</option>
				
				<option value="file21">github.com/arthur-debert/padz/pkg/logging/logging.go (0.0%)</option>
				
				<option value="file22">github.com/arthur-debert/padz/pkg/project/project.go (0.0%)</option>
				
				<option value="file23">github.com/arthur-debert/padz/pkg/store/store.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "os"

        "github.com/arthur-debert/padz/cmd/padz/cli"
)

func main() <span class="cov0" title="0">{
        if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Usage: %s &lt;bash|zsh|fish|powershell&gt;\n", os.Args[0])
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">shell := os.Args[1]
        rootCmd := cli.NewRootCmd()

        var err error
        switch shell </span>{
        case "bash":<span class="cov0" title="0">
                err = rootCmd.GenBashCompletion(os.Stdout)</span>
        case "zsh":<span class="cov0" title="0">
                err = rootCmd.GenZshCompletion(os.Stdout)</span>
        case "fish":<span class="cov0" title="0">
                err = rootCmd.GenFishCompletion(os.Stdout, true)</span>
        case "powershell":<span class="cov0" title="0">
                err = rootCmd.GenPowerShellCompletionWithDesc(os.Stdout)</span>
        default:<span class="cov0" title="0">
                fmt.Fprintf(os.Stderr, "Unknown shell: %s\n", shell)
                fmt.Fprintf(os.Stderr, "Supported shells: bash, zsh, fish, powershell\n")
                os.Exit(1)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error generating %s completion: %v\n", shell, err)
                os.Exit(1)
        }</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "os"

        "github.com/spf13/cobra/doc"

        "github.com/arthur-debert/padz/cmd/padz/cli"
        "github.com/arthur-debert/padz/internal/version"
)

func main() <span class="cov0" title="0">{
        rootCmd := cli.NewRootCmd()

        header := &amp;doc.GenManHeader{
                Title:   "PADZ",
                Section: "1",
                Source:  "padz " + version.Version,
                Manual:  "padz manual",
        }

        err := doc.GenMan(rootCmd, header, os.Stdout)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error generating man page: %v\n", err)
                os.Exit(1)
        }</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright © 2025 YOUR NAME HERE &lt;EMAIL ADDRESS&gt;
*/
package cli

import (
        "fmt"
        "log"
        "github.com/arthur-debert/padz/pkg/commands"
        "github.com/arthur-debert/padz/pkg/store"

        "github.com/spf13/cobra"
)

// cleanupCmd represents the cleanup command
var cleanupCmd = &amp;cobra.Command{
        Use:   "cleanup",
        Short: "Cleanup old scratches",
        Long:  `Cleanup scratches older than a specified number of days.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                days, _ := cmd.Flags().GetInt("days")

                s, err := store.NewStore()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">if err := commands.Cleanup(s, days); err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">fmt.Println("Cleanup complete.")</span>
        },
}

</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright © 2025 YOUR NAME HERE &lt;EMAIL ADDRESS&gt;
*/
package cli

import (
        "fmt"
        "log"
        "os"
        "github.com/arthur-debert/padz/pkg/commands"
        "github.com/arthur-debert/padz/pkg/project"
        "github.com/arthur-debert/padz/pkg/store"

        "github.com/spf13/cobra"
)

// deleteCmd represents the delete command
var deleteCmd = &amp;cobra.Command{
        Use:   "delete [index]",
        Short: "Delete a scratch",
        Long:  `Delete a scratch identified by its index.`,
        Args:  cobra.ExactArgs(1),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                s, err := store.NewStore()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">dir, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">proj, err := project.GetCurrentProject(dir)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">if err := commands.Delete(s, proj, args[0]); err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">fmt.Println("Scratch deleted.")</span>
        },
}

</pre>
		
		<pre class="file" id="file4" style="display: none">/*
Copyright © 2025 YOUR NAME HERE &lt;EMAIL ADDRESS&gt;
*/
package cli

import (
        "fmt"
        "log"
        "os"
        "github.com/arthur-debert/padz/pkg/commands"
        "github.com/arthur-debert/padz/pkg/project"
        "github.com/arthur-debert/padz/pkg/store"

        "github.com/dustin/go-humanize"
        "github.com/spf13/cobra"
)

// lsCmd represents the ls command
var lsCmd = &amp;cobra.Command{
        Use:   "ls",
        Short: "Lists all scratches for the current project",
        Long: `Lists all scratches for the current project.
The output includes the index, the relative time of creation, and the title of the scratch.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                all, _ := cmd.Flags().GetBool("all")
                global, _ := cmd.Flags().GetBool("global")

                s, err := store.NewStore()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">dir, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">proj, err := project.GetCurrentProject(dir)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">scratches := commands.Ls(s, all, global, proj)

                for i, scratch := range scratches </span><span class="cov0" title="0">{
                        if all </span><span class="cov0" title="0">{
                                fmt.Printf("%d. %s %s %s\n", i+1, scratch.Project, humanize.Time(scratch.CreatedAt), scratch.Title)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("%d. %s %s\n", i+1, humanize.Time(scratch.CreatedAt), scratch.Title)
                        }</span>
                }
        },
}

</pre>
		
		<pre class="file" id="file5" style="display: none">/*
Copyright © 2025 YOUR NAME HERE &lt;EMAIL ADDRESS&gt;
*/
package cli

import (
        "fmt"
        "log"
        "os"
        "github.com/arthur-debert/padz/pkg/commands"
        "github.com/arthur-debert/padz/pkg/project"
        "github.com/arthur-debert/padz/pkg/store"

        "github.com/spf13/cobra"
)

// openCmd represents the open command
var openCmd = &amp;cobra.Command{
        Use:   "open [index]",
        Short: "Open a scratch in the default editor",
        Long:  `Open a scratch, identified by its index, in the default editor.`,
        Args:  cobra.ExactArgs(1),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                s, err := store.NewStore()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">dir, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">proj, err := project.GetCurrentProject(dir)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">if err := commands.Open(s, proj, args[0]); err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">fmt.Println("Scratch updated.")</span>
        },
}

</pre>
		
		<pre class="file" id="file6" style="display: none">/*
Copyright © 2025 YOUR NAME HERE &lt;EMAIL ADDRESS&gt;
*/
package cli

import (
        "fmt"
        "log"
        "os"
        "github.com/arthur-debert/padz/pkg/commands"
        "github.com/arthur-debert/padz/pkg/project"
        "github.com/arthur-debert/padz/pkg/store"

        "github.com/spf13/cobra"
)

// peekCmd represents the peek command
var peekCmd = &amp;cobra.Command{
        Use:   "peek [index]",
        Short: "Peek at a scratch",
        Long:  `Peek at the first and last lines of a scratch.`,
        Args:  cobra.ExactArgs(1),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                all, _ := cmd.Flags().GetBool("all")
                global, _ := cmd.Flags().GetBool("global")
                lines, _ := cmd.Flags().GetInt("lines")

                s, err := store.NewStore()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">dir, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">proj, err := project.GetCurrentProject(dir)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">content, err := commands.Peek(s, all, global, proj, args[0], lines)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">fmt.Print(content)</span>
        },
}

</pre>
		
		<pre class="file" id="file7" style="display: none">package cli

import (
        "fmt"
        "os"

        "github.com/arthur-debert/padz/internal/version"
        "github.com/arthur-debert/padz/pkg/commands"
        "github.com/arthur-debert/padz/pkg/logging"
        "github.com/arthur-debert/padz/pkg/project"
        "github.com/arthur-debert/padz/pkg/store"
        "github.com/rs/zerolog/log"
        "github.com/spf13/cobra"
)

var (
        verbosity int
        verbose   bool
        debug     bool
)

// NewRootCmd creates and returns the root command
func NewRootCmd() *cobra.Command <span class="cov0" title="0">{
        rootCmd := &amp;cobra.Command{
                Use:   "padz",
                Short: "A simple command-line note-taking tool",
                Long: `padz is a simple shell command to create, search, view, and edit quick notes.
It uses the user's default command-line editor for note creation and editing,
and focuses on streamlined content management.`,
                DisableAutoGenTag: true,
                CompletionOptions: cobra.CompletionOptions{
                        DisableDefaultCmd: true,
                },
                PersistentPreRun: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        // Setup logging based on verbosity
                        logging.SetupLogger(verbosity)
                        log.Debug().Str("command", cmd.Name()).Msg("Command started")
                }</span>,
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        s, err := store.NewStore()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatal().Err(err).Msg("Failed to initialize store")
                        }</span>

                        <span class="cov0" title="0">dir, err := os.Getwd()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatal().Err(err).Msg("Failed to get working directory")
                        }</span>

                        <span class="cov0" title="0">proj, err := project.GetCurrentProject(dir)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatal().Err(err).Msg("Failed to get current project")
                        }</span>

                        <span class="cov0" title="0">content := commands.ReadContentFromPipe()
                        if err := commands.Create(s, proj, content); err != nil </span><span class="cov0" title="0">{
                                log.Fatal().Err(err).Msg("Failed to create note")
                        }</span>
                },
        }

        // Setup persistent flags
        <span class="cov0" title="0">rootCmd.PersistentFlags().CountVarP(&amp;verbosity, "verbose", "v", "Increase verbosity (-v, -vv, -vvv)")
        rootCmd.PersistentFlags().BoolVar(&amp;verbose, "verbose-old", false, "Enable verbose output")
        rootCmd.PersistentFlags().BoolVar(&amp;debug, "debug", false, "Enable debug output")

        // Add version command
        rootCmd.AddCommand(&amp;cobra.Command{
                Use:   "version",
                Short: "Print the version number",
                Long:  `Print the version number of padz`,
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        fmt.Printf("padz version %s (commit: %s, built: %s)\n", 
                                version.Version, version.Commit, version.Date)
                }</span>,
        })

        // Add all the subcommands with their flags
        <span class="cov0" title="0">lsCmd.Flags().Bool("all", false, "Show scratches from all projects")
        lsCmd.Flags().Bool("global", false, "Show only global scratches")
        rootCmd.AddCommand(lsCmd)
        
        rootCmd.AddCommand(viewCmd)
        rootCmd.AddCommand(openCmd)
        rootCmd.AddCommand(deleteCmd)
        
        searchCmd.Flags().BoolP("all", "a", false, "Search in all projects")
        searchCmd.Flags().BoolP("global", "g", false, "Search in global scratches only")
        rootCmd.AddCommand(searchCmd)
        
        peekCmd.Flags().IntP("lines", "n", 5, "Number of lines to show from the beginning and end")
        rootCmd.AddCommand(peekCmd)
        
        cleanupCmd.Flags().IntP("days", "d", 30, "Delete scratches older than this many days")
        rootCmd.AddCommand(cleanupCmd)

        return rootCmd</span>
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() error <span class="cov0" title="0">{
        return NewRootCmd().Execute()
}</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Copyright © 2025 YOUR NAME HERE &lt;EMAIL ADDRESS&gt;
*/
package cli

import (
        "fmt"
        "log"
        "os"
        "github.com/arthur-debert/padz/pkg/commands"
        "github.com/arthur-debert/padz/pkg/project"
        "github.com/arthur-debert/padz/pkg/store"

        "github.com/dustin/go-humanize"
        "github.com/spf13/cobra"
)

// searchCmd represents the search command
var searchCmd = &amp;cobra.Command{
        Use:   "search [term]",
        Short: "Search for a scratch",
        Long:  `Search for a scratch by a regular expression.`,
        Args:  cobra.ExactArgs(1),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                all, _ := cmd.Flags().GetBool("all")
                global, _ := cmd.Flags().GetBool("global")

                s, err := store.NewStore()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">dir, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">proj, err := project.GetCurrentProject(dir)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">scratches, err := commands.Search(s, all, global, proj, args[0])
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">for i, scratch := range scratches </span><span class="cov0" title="0">{
                        fmt.Printf("%d. %s %s\n", i+1, humanize.Time(scratch.CreatedAt), scratch.Title)
                }</span>
        },
}

</pre>
		
		<pre class="file" id="file9" style="display: none">/*
Copyright © 2025 YOUR NAME HERE &lt;EMAIL ADDRESS&gt;
*/
package cli

import (
        "fmt"
        "log"
        "os"
        "os/exec"
        "github.com/arthur-debert/padz/pkg/commands"
        "github.com/arthur-debert/padz/pkg/project"
        "github.com/arthur-debert/padz/pkg/store"
        "strings"

        "github.com/spf13/cobra"
)

// viewCmd represents the view command
var viewCmd = &amp;cobra.Command{
        Use:   "view [index]",
        Short: "View a scratch",
        Long:  `View the content of a scratch identified by its index.`,
        Args:  cobra.ExactArgs(1),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                all, _ := cmd.Flags().GetBool("all")
                global, _ := cmd.Flags().GetBool("global")

                s, err := store.NewStore()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">dir, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">proj, err := project.GetCurrentProject(dir)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">content, err := commands.View(s, all, global, proj, args[0])
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                // Check if output is being piped
                <span class="cov0" title="0">info, _ := os.Stdout.Stat()
                if (info.Mode() &amp; os.ModeCharDevice) == 0 </span><span class="cov0" title="0">{
                        fmt.Print(content)
                }</span> else<span class="cov0" title="0"> {
                        // Use a pager
                        pager := os.Getenv("PAGER")
                        if pager == "" </span><span class="cov0" title="0">{
                                pager = "less"
                        }</span>
                        <span class="cov0" title="0">c := exec.Command(pager)
                        c.Stdin = strings.NewReader(content)
                        c.Stdout = os.Stdout
                        if err := c.Run(); err != nil </span><span class="cov0" title="0">{
                                log.Fatal(err)
                        }</span>
                }
        },
}

</pre>
		
		<pre class="file" id="file10" style="display: none">package main

import (
        "os"
        
        "github.com/arthur-debert/padz/cmd/padz/cli"
)

func main() <span class="cov0" title="0">{
        if err := cli.Execute(); err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
} </pre>
		
		<pre class="file" id="file11" style="display: none">// Package version provides version information for my-cli
package version

// Build-time variables set by ldflags
var (
        // Version is the semantic version
        Version = "dev"

        // Commit is the git commit SHA
        Commit = "unknown"

        // Date is the build date
        Date = "unknown"
)

// Info returns formatted version information
func Info() string <span class="cov0" title="0">{
        return Version + " (commit: " + Commit + ", built: " + Date + ")"
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package commands

import (
        "github.com/arthur-debert/padz/pkg/store"
        "time"
)

func Cleanup(s *store.Store, days int) error <span class="cov0" title="0">{
        scratches := s.GetScratches()
        cutoff := time.Now().AddDate(0, 0, -days)

        var scratchesToKeep []store.Scratch
        var scratchesToDelete []store.Scratch

        for _, scratch := range scratches </span><span class="cov0" title="0">{
                if scratch.CreatedAt.Before(cutoff) </span><span class="cov0" title="0">{
                        scratchesToDelete = append(scratchesToDelete, scratch)
                }</span> else<span class="cov0" title="0"> {
                        scratchesToKeep = append(scratchesToKeep, scratch)
                }</span>
        }

        <span class="cov0" title="0">for _, scratch := range scratchesToDelete </span><span class="cov0" title="0">{
                if err := deleteScratchFile(scratch.ID); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return s.SaveScratches(scratchesToKeep)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package commands

import (
        "bufio"
        "bytes"
        "crypto/sha1"
        "fmt"
        "io"
        "os"
        "github.com/arthur-debert/padz/pkg/editor"
        "github.com/arthur-debert/padz/pkg/store"
        "strings"
        "time"
)

func Create(s *store.Store, project string, content []byte) error <span class="cov0" title="0">{
        var err error
        if len(content) == 0 </span><span class="cov0" title="0">{
                content, err = editor.OpenInEditor(nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">trimmedContent := trim(content)
        if len(trimmedContent) == 0 </span><span class="cov0" title="0">{
                return nil // Don't save empty scratches
        }</span>

        <span class="cov0" title="0">title := getTitle(trimmedContent)
        id := fmt.Sprintf("%x", sha1.Sum(trimmedContent))

        scratch := store.Scratch{
                ID:        id,
                Project:   project,
                Title:     title,
                CreatedAt: time.Now(),
        }

        if err := saveScratchFile(id, trimmedContent); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return s.AddScratch(scratch)</span>
}

func getTitle(content []byte) string <span class="cov0" title="0">{
        reader := bytes.NewReader(content)
        scanner := bufio.NewScanner(reader)
        if scanner.Scan() </span><span class="cov0" title="0">{
                return scanner.Text()
        }</span>
        <span class="cov0" title="0">return "Untitled"</span>
}

func trim(content []byte) []byte <span class="cov0" title="0">{
        return []byte(strings.Trim(string(content), "\n\t "))
}</span>

func saveScratchFile(id string, content []byte) error <span class="cov0" title="0">{
        path, err := store.GetScratchFilePath(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, content, 0644)</span>
}

func ReadContentFromPipe() []byte <span class="cov0" title="0">{
        info, err := os.Stdin.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if info.Mode()&amp;os.ModeNamedPipe == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">var buf bytes.Buffer
        io.Copy(&amp;buf, os.Stdin)
        return buf.Bytes()</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package commands

import (
        "fmt"
        "os"
        "github.com/arthur-debert/padz/pkg/store"
        "strconv"
)

func Delete(s *store.Store, project string, indexStr string) error <span class="cov0" title="0">{
        scratches := Ls(s, false, false, project)

        index, err := strconv.Atoi(indexStr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid index: %s", indexStr)
        }</span>

        <span class="cov0" title="0">if index &lt; 1 || index &gt; len(scratches) </span><span class="cov0" title="0">{
                return fmt.Errorf("index out of range: %d", index)
        }</span>

        <span class="cov0" title="0">scratchToDelete := scratches[index-1]

        if err := deleteScratchFile(scratchToDelete.ID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return s.RemoveScratch(scratchToDelete.ID)</span>
}

func deleteScratchFile(id string) error <span class="cov0" title="0">{
        path, err := store.GetScratchFilePath(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.Remove(path)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package commands

import (
        "github.com/arthur-debert/padz/pkg/store"
)

func Ls(s *store.Store, all, global bool, project string) []store.Scratch <span class="cov0" title="0">{
        scratches := s.GetScratches()
        if all </span><span class="cov0" title="0">{
                return scratches
        }</span>

        <span class="cov0" title="0">var filtered []store.Scratch
        for _, scratch := range scratches </span><span class="cov0" title="0">{
                if global &amp;&amp; scratch.Project == "global" </span><span class="cov0" title="0">{
                        filtered = append(filtered, scratch)
                }</span> else<span class="cov0" title="0"> if !global &amp;&amp; scratch.Project == project </span><span class="cov0" title="0">{
                        filtered = append(filtered, scratch)
                }</span>
        }
        <span class="cov0" title="0">return filtered</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package commands

import (
        "fmt"
        "github.com/arthur-debert/padz/pkg/editor"
        "github.com/arthur-debert/padz/pkg/store"
        "strconv"
)

func Open(s *store.Store, project string, indexStr string) error <span class="cov0" title="0">{
        scratches := Ls(s, false, false, project)

        index, err := strconv.Atoi(indexStr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid index: %s", indexStr)
        }</span>

        <span class="cov0" title="0">if index &lt; 1 || index &gt; len(scratches) </span><span class="cov0" title="0">{
                return fmt.Errorf("index out of range: %d", index)
        }</span>

        <span class="cov0" title="0">scratchToOpen := scratches[index-1]

        content, err := readScratchFile(scratchToOpen.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">newContent, err := editor.OpenInEditor(content)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">trimmedContent := trim(newContent)
        if len(trimmedContent) == 0 </span><span class="cov0" title="0">{
                // If the file is empty, delete the scratch
                if err := deleteScratchFile(scratchToOpen.ID); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return s.RemoveScratch(scratchToOpen.ID)</span>
        }

        <span class="cov0" title="0">if err := saveScratchFile(scratchToOpen.ID, trimmedContent); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">scratchToOpen.Title = getTitle(trimmedContent)
        return s.UpdateScratch(scratchToOpen)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package commands

import (
        "bufio"
        "bytes"
        "github.com/arthur-debert/padz/pkg/store"
        "strings"
)

func Peek(s *store.Store, all, global bool, project string, indexStr string, lines int) (string, error) <span class="cov0" title="0">{
        content, err := View(s, all, global, project, indexStr)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">scanner := bufio.NewScanner(strings.NewReader(content))
        var contentLines []string
        for scanner.Scan() </span><span class="cov0" title="0">{
                contentLines = append(contentLines, scanner.Text())
        }</span>

        <span class="cov0" title="0">if len(contentLines) &lt;= 2*lines </span><span class="cov0" title="0">{
                return content, nil
        }</span>

        <span class="cov0" title="0">var result bytes.Buffer
        for i := 0; i &lt; lines; i++ </span><span class="cov0" title="0">{
                result.WriteString(contentLines[i])
                result.WriteString("\n")
        }</span>
        <span class="cov0" title="0">result.WriteString("...\n")
        for i := len(contentLines) - lines; i &lt; len(contentLines); i++ </span><span class="cov0" title="0">{
                result.WriteString(contentLines[i])
                result.WriteString("\n")
        }</span>

        <span class="cov0" title="0">return result.String(), nil</span>
}</pre>
		
		<pre class="file" id="file18" style="display: none">package commands

import (
        "regexp"
        "github.com/arthur-debert/padz/pkg/store"
)

func Search(s *store.Store, all, global bool, project, term string) ([]store.Scratch, error) <span class="cov0" title="0">{
        scratches := Ls(s, all, global, project)

        re, err := regexp.Compile(term)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var filtered []store.Scratch
        for _, scratch := range scratches </span><span class="cov0" title="0">{
                content, err := readScratchFile(scratch.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if re.Match(content) </span><span class="cov0" title="0">{
                        filtered = append(filtered, scratch)
                }</span>
        }

        <span class="cov0" title="0">return filtered, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package commands

import (
        "fmt"
        "os"
        "github.com/arthur-debert/padz/pkg/store"
        "strconv"
)

func View(s *store.Store, all, global bool, project string, indexStr string) (string, error) <span class="cov0" title="0">{
        scratches := Ls(s, all, global, project)

        index, err := strconv.Atoi(indexStr)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid index: %s", indexStr)
        }</span>

        <span class="cov0" title="0">if index &lt; 1 || index &gt; len(scratches) </span><span class="cov0" title="0">{
                return "", fmt.Errorf("index out of range: %d", index)
        }</span>

        <span class="cov0" title="0">scratch := scratches[index-1]

        content, err := readScratchFile(scratch.ID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return string(content), nil</span>
}

func readScratchFile(id string) ([]byte, error) <span class="cov0" title="0">{
        path, err := store.GetScratchFilePath(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return os.ReadFile(path)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package editor

import (
        "os"
        "os/exec"
)

func OpenInEditor(content []byte) ([]byte, error) <span class="cov0" title="0">{
        editor := os.Getenv("EDITOR")
        if editor == "" </span><span class="cov0" title="0">{
                editor = "vim" // default to vim
        }</span>

        <span class="cov0" title="0">tmpfile, err := os.CreateTemp("", "scratch-")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer os.Remove(tmpfile.Name())

        if len(content) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := tmpfile.Write(content); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">if err := tmpfile.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">cmd := exec.Command(editor, tmpfile.Name())
        cmd.Stdin = os.Stdin
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return os.ReadFile(tmpfile.Name())</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package logging

import (
        "os"
        "time"

        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

// SetupLogger configures the global logger based on verbosity level
func SetupLogger(verbosity int) <span class="cov0" title="0">{
        // Configure zerolog based on verbosity
        switch verbosity </span>{
        case 0:<span class="cov0" title="0">
                zerolog.SetGlobalLevel(zerolog.WarnLevel)</span>
        case 1:<span class="cov0" title="0">
                zerolog.SetGlobalLevel(zerolog.InfoLevel)</span>
        case 2:<span class="cov0" title="0">
                zerolog.SetGlobalLevel(zerolog.DebugLevel)</span>
        default:<span class="cov0" title="0">
                zerolog.SetGlobalLevel(zerolog.TraceLevel)</span>
        }

        // Configure console output with pretty printing
        <span class="cov0" title="0">output := zerolog.ConsoleWriter{
                Out:        os.Stderr,
                TimeFormat: time.RFC3339,
                NoColor:    false,
        }

        log.Logger = log.Output(output)

        // Add caller information for debug and trace levels
        if verbosity &gt;= 2 </span><span class="cov0" title="0">{
                log.Logger = log.Logger.With().Caller().Logger()
        }</span>

        // Log the logging level
        <span class="cov0" title="0">log.Debug().Int("verbosity", verbosity).Msg("Logger initialized")</span>
}

// GetLogger returns a contextualized logger with the given name
func GetLogger(name string) zerolog.Logger <span class="cov0" title="0">{
        return log.With().Str("component", name).Logger()
}</span>

// WithFields returns a logger with additional fields
func WithFields(fields map[string]interface{}) zerolog.Logger <span class="cov0" title="0">{
        logger := log.Logger
        for k, v := range fields </span><span class="cov0" title="0">{
                logger = logger.With().Interface(k, v).Logger()
        }</span>
        <span class="cov0" title="0">return logger</span>
}</pre>
		
		<pre class="file" id="file22" style="display: none">package project

import (
        "os"
        "path/filepath"
)

func GetCurrentProject(dir string) (string, error) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                if _, err := os.Stat(filepath.Join(dir, ".git")); err == nil </span><span class="cov0" title="0">{
                        return filepath.Base(dir), nil
                }</span>

                <span class="cov0" title="0">parent := filepath.Dir(dir)
                if parent == dir </span><span class="cov0" title="0">{
                        return "global", nil
                }</span>
                <span class="cov0" title="0">dir = parent</span>
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package store

import (
        "encoding/json"
        "os"
        "path/filepath"
        "sync"

        "github.com/adrg/xdg"
)

const (
        dataDirName      = "scratch"
        metadataFileName = "metadata.json"
)

type Store struct {
        mu        sync.Mutex
        scratches []Scratch
}

func NewStore() (*Store, error) <span class="cov0" title="0">{
        store := &amp;Store{}
        if err := store.load(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return store, nil</span>
}

func (s *Store) GetScratches() []Scratch <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        return s.scratches
}</span>

func (s *Store) SaveScratches(scratches []Scratch) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.scratches = scratches
        return s.save()
}</span>

func (s *Store) load() error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        path, err := getMetadataPath()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov0" title="0">{
                s.scratches = []Scratch{}
                return nil
        }</span>

        <span class="cov0" title="0">data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return json.Unmarshal(data, &amp;s.scratches)</span>
}

func (s *Store) save() error <span class="cov0" title="0">{
        path, err := getMetadataPath()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">data, err := json.MarshalIndent(s.scratches, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

func (s *Store) AddScratch(scratch Scratch) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.scratches = append(s.scratches, scratch)
        return s.save()
}</span>

func (s *Store) RemoveScratch(id string) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        var newScratches []Scratch
        for _, scratch := range s.scratches </span><span class="cov0" title="0">{
                if scratch.ID != id </span><span class="cov0" title="0">{
                        newScratches = append(newScratches, scratch)
                }</span>
        }
        <span class="cov0" title="0">s.scratches = newScratches
        return s.save()</span>
}

func (s *Store) UpdateScratch(scratchToUpdate Scratch) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        for i, scratch := range s.scratches </span><span class="cov0" title="0">{
                if scratch.ID == scratchToUpdate.ID </span><span class="cov0" title="0">{
                        s.scratches[i] = scratchToUpdate
                        break</span>
                }
        }
        <span class="cov0" title="0">return s.save()</span>
}

func GetScratchPath() (string, error) <span class="cov0" title="0">{
        path, err := xdg.DataFile(dataDirName)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if err := os.MkdirAll(path, 0755); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return path, nil</span>
}

func GetScratchFilePath(id string) (string, error) <span class="cov0" title="0">{
        path, err := GetScratchPath()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return filepath.Join(path, id), nil</span>
}

func getMetadataPath() (string, error) <span class="cov0" title="0">{
        path, err := GetScratchPath()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return filepath.Join(path, metadataFileName), nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
