# Selectors: Multi-IDs and Ranges

## The Problem

Users often need to act on batches of items ("Delete the last 3 notes", "Pin items 1 and 5").
Typing `padz delete 1 2 3` is okay, but `padz delete 1-3` is better.
However, range logic is tricky when indexes (pinned vs regular) are involved. Mixing types (`p1-3`) is ambiguous.

## The Solution: Typed Selectors

Padz implements a strong grammar for selecting items. A "Selector" is the user's intent string, which must be parsed and validated before it ever touches the business logic.

### 1. The Grammar

-   **Regular Index**: `N` (e.g., `1`, `42`)
-   **Pinned Index**: `pX` (e.g., `p1`, `p2`)
-   **Deleted Index**: `dX` (e.g., `d1`, `d5`)
-   **Ranges**: `Start-End` (e.g., `1-5`, `p1-p3`)
    -   **Constraint**: Must be Homogenous. `1-3` is valid. `p1-p3` is valid. `1-p3` is **Invalid**.

### 2. Application Logic

**Phase 1: Parsing (The "What")**
-   **Location**: [`padz::index::parse_index_or_range`](file:///src/padz/index.rs)
-   **Role**: Expands string inputs into a list of `DisplayIndex` enums.
-   **Example**: Input `"1-3"` -> Output `vec![Regular(1), Regular(2), Regular(3)]`.

**Phase 2: Resolution (The "Who")**
-   **Location**: [`padz::api::parse_selectors`](file:///src/padz/api.rs)
-   **Role**: Maps `DisplayIndex` -> `UUID` using proper `index_pads` sorting.
-   **Logic**:
    1.  Calls `index_pads(store.list())` to get the current state of the world.
    2.  Finds the UUID corresponding to `Regular(1)`, `Regular(2)`, etc.
    3.  If any index is out of bounds, returns an Error.

**Phase 3: Fallback (Search)**
-   If parsing fails (string is not a valid index/range syntax), the entire input is treated as a **Search Term**.
-   `padz list meeting` -> "meeting" is not an index -> Treated as `padz list --search meeting`.

### Developer Note
This layered approach means the `commands` module never deals with parsing logic. It simply receives `Vec<Uuid>` or a `SearchTerm` string.
