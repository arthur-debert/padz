#!/usr/bin/env bash
# =============================================================================
# PADZ LIVE TEST RUNNER
# =============================================================================
#
# PURPOSE (WHY)
# -------------
# Unit tests are great for isolated logic, but real-world CLI tools need
# end-to-end validation in realistic environments. This script creates an
# isolated sandbox where you can:
#
#   1. Test the latest dev build against real filesystem operations
#   2. Verify both global and project-scoped pad behavior
#   3. Run reproducible test scripts or explore interactively
#   4. Avoid polluting your real padz data
#
# DESIGN DECISIONS
# ----------------
# 1. OS-managed temp dir: We use the system's temp directory (via mktemp)
#    rather than a project-local tmp/. This ensures proper cleanup by the OS
#    and avoids cluttering the repo.
#
# 2. Global data isolation: We set PADZ_GLOBAL_DATA to point to our temp dir.
#    This isolates the "global" scope entirely - no risk of touching real data.
#
# 3. Dual-scope structure: We create both a project directory (with .git) and
#    a global-data directory. This lets you test scope interactions:
#      - workspace/projects/project-a/ -> project scope (has .git)
#      - workspace/global-data/        -> global scope (via PADZ_GLOBAL_DATA)
#
# 4. EDITOR=true: The `true` command exits immediately with success code 0.
#    This prevents scripts from hanging on editor prompts. For interactive
#    sessions, override with: export EDITOR=vim (or your preferred editor).
#
# 5. Fresh binary: We always build before running to ensure you're testing
#    the latest code, not a stale binary.
#
# DIRECTORY STRUCTURE
# -------------------
# After setup, you'll be in:
#
#   /tmp/padz-live-XXXXX/           <- workspace root (your cwd)
#   ├── projects/
#   │   └── project-a/              <- cd here for project-scoped testing
#   │       └── .git/
#   └── global-data/                <- PADZ_GLOBAL_DATA points here
#                                      global pads stored directly here
#
# USAGE
# -----
#   live-tests/run                     # interactive shell in workspace
#   live-tests/run <script>            # run script, then exit
#   live-tests/run <script> -i         # run script, then interactive shell
#   live-tests/run -i <script>         # same as above
#
# =============================================================================

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
GRAY='\033[38;5;245m'
NC='\033[0m'

usage() {
    echo "Usage: ./run [options] [script_file]"
    echo
    echo "Create an isolated sandbox for end-to-end padz testing."
    echo
    echo "Options:"
    echo "  -i, --interactive    Start interactive shell after script execution"
    echo "  -h, --help           Show this help message"
    echo
    echo "Examples:"
    echo "  live-tests/run                        # Interactive exploration"
    echo "  live-tests/run base-fixture.sh        # Set up fixture data"
    echo "  live-tests/run base-fixture.sh -i     # Fixture + interactive"
}

# Parse arguments
SCRIPT_FILE=""
INTERACTIVE=false
while [[ $# -gt 0 ]]; do
    case $1 in
    -h | --help)
        usage
        exit 0
        ;;
    -i | --interactive)
        INTERACTIVE=true
        shift
        ;;
    *)
        if [[ -z "${SCRIPT_FILE}" ]]; then
            SCRIPT_FILE="${1}"
        else
            echo -e "${RED}Error: Too many arguments${NC}" >&2
            usage
            exit 1
        fi
        shift
        ;;
    esac
done

# Resolve script file path
if [[ -n "${SCRIPT_FILE}" ]]; then
    if [[ ! -f "${SCRIPT_FILE}" ]]; then
        if [[ -f "${SCRIPT_DIR}/${SCRIPT_FILE}" ]]; then
            SCRIPT_FILE="${SCRIPT_DIR}/${SCRIPT_FILE}"
        else
            echo -e "${RED}Error: Script '${SCRIPT_FILE}' not found${NC}" >&2
            exit 1
        fi
    fi
    SCRIPT_FILE="$(cd "$(dirname "${SCRIPT_FILE}")" && pwd)/$(basename "${SCRIPT_FILE}")"
    [[ ! -x "${SCRIPT_FILE}" ]] && chmod +x "${SCRIPT_FILE}"
fi

# Build fresh binary
PADZ_BIN="${PROJECT_ROOT}/target/debug/padz"
echo -e "${GRAY}Building padz...${NC}"
if ! (cd "${PROJECT_ROOT}" && cargo build --bin padz 2>&1 | grep -E "Compiling|Finished|error" || true); then
    echo -e "${RED}Build failed${NC}" >&2
    exit 1
fi
[[ ! -x "${PADZ_BIN}" ]] && { echo -e "${RED}Binary not found${NC}" >&2; exit 1; }

# Create workspace in OS temp directory
WORKSPACE="$(mktemp -d)"
echo -e "${GRAY}Workspace: ${WORKSPACE}${NC}"

cleanup() {
    echo -e "\n${YELLOW}Cleaning up...${NC}"
    rm -rf "${WORKSPACE}"
    echo -e "${GREEN}Done${NC}"
}
trap cleanup EXIT INT TERM

# Set up directory structure
mkdir -p "${WORKSPACE}/projects/project-a"
mkdir -p "${WORKSPACE}/global-data"

# Initialize git in project-a
(cd "${WORKSPACE}/projects/project-a" && git init --quiet)

# Export environment for the subshell
export PADZ_BIN
export WORKSPACE
export PADZ_GLOBAL_DATA="${WORKSPACE}/global-data"
export EDITOR=true
export HISTFILE="${WORKSPACE}/.zsh_history"
export HISTSIZE=10000
export SAVEHIST=10000

# Change to workspace root
cd "${WORKSPACE}"

# Function to run script via wrapper
run_script() {
    local script="$1"
    echo -e "${GRAY}Running: $(basename "${script}")${NC}\n"

    # Create wrapper with substitutions
    sed -e "s|__WORKSPACE__|${WORKSPACE}|g" \
        -e "s|__PADZ_BIN__|${PADZ_BIN}|g" \
        "${SCRIPT_DIR}/.wrapper" > "${WORKSPACE}/.wrapper.zsh"
    chmod +x "${WORKSPACE}/.wrapper.zsh"

    zsh --no-globalrcs --no-rcs "${WORKSPACE}/.wrapper.zsh" "${script}"
}

# Function to start interactive shell
start_interactive() {
    echo -e "\n${YELLOW}$(cat "${SCRIPT_DIR}/.welcome")${NC}\n"

    # Prepare zshrc
    sed -e "s|__WORKSPACE__|${WORKSPACE}|g" \
        -e "s|__PADZ_BIN__|${PADZ_BIN}|g" \
        "${SCRIPT_DIR}/.zshrc" > "${WORKSPACE}/.zshrc"

    ZDOTDIR="${WORKSPACE}" zsh -i
}

# Execute
if [[ -n "${SCRIPT_FILE}" ]]; then
    run_script "${SCRIPT_FILE}"
    [[ "${INTERACTIVE}" == "true" ]] && start_interactive
else
    start_interactive
fi
